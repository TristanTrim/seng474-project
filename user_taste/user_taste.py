#!/usr/bin/env python3
# -*- coding: utf-8 -*-


"""
Implementation of user taste module

NOTE: This module requires the user taste dataset to be available. This file can be generated by running entp_reader.py


"""
import user_taste as UT
import numpy as np 
from numpy.random import randint
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from music_space.music_space import music_space

# ^ commented out these modules, cvxpy doesn't like them

class user_taste():

    def __init__(self,path):
        self.taste_space = np.load(path + 'user_taste.npy')
        self.taste_dictionary = self.__init_taste_dictionary()
        self.score_matrix = None

        self._all_users = np.unique(self.taste_space[:,0])
        self._all_songs = np.unique(self.taste_space[:,1])

        """
        score matrix format:
            n = number of users
            m = number of songs
            the matrix must be n x m:
            the value at row i, column j is the ith users rating of the jth song
        """



    def __init_taste_dictionary(self):
        """constructs a dictionary of (sid,uid) : score pairs"""
        #group the sid and uid together into tuples
        keys = map(tuple, self.taste_space[:, :2])

        #cast the scores to int
        values = self.taste_space[:, 2].astype(int)

        taste_dictionary = dict(zip(keys, values))
        return taste_dictionary

    def get_song_score(self,uid,sid):
        """return the score given a user id (uid) and song id (sid)
        Dont use this function
        """

        listening_history = self.get_listening_history(uid)
        for song in list(listening_history[:, 1]):
            if song == sid:
                return self.taste_dictionary[(uid,sid)]

        return 0
    
    def get_rand_user(self):
        """returns the user id (uid) of a random user in the user taste dataframe"""
    
        i = randint(0,self.taste_space.shape[0]-1)
        return self.taste_space[i,0]
    
    def get_listening_history(self,uid):
        """return all the songs which a given user has listened to"""
        uid_records = self.taste_space[:,0] == uid
        return self.taste_space[uid_records]

    def get_all_users(self):
        return self._all_users

    def get_all_songs(self):
        return self._all_songs



class MC_score_matrix(user_taste):
    
    '''
    extension of user_taste to include  implementation of score matrix
    and a key-index mapping
    '''
    
    def __init__(self,path,n_users=100,solve=False):
        super().__init__(path)
        self.n_users = n_users
        self.index_dictionary = self.__get_index_dictionary()
        
        
        if solve:
            self.__init_score_matrix(path)
            self.score_matrix = self.__MC_solve(path)
        
        else:
            #self.score_matrix = np.load(path+'small_score_matrix.npy')
            self.__init_score_matrix(path)
        
    def limit_ind_dict_to_sco_mat(self):
        kv = list(self.index_dictionary.items())
        kv = np.array(kv)
        inds = kv[:,1].astype(int)
        init = (inds<self.score_matrix.shape).all(1)
        kv = kv[init]

        dic = dict([
                ( (x[0,0],x[0,1]), (x[1,0],x[1,1]) )
                                        for x in kv ])

        self.index_dictionary = dic

        i = np.in1d( self._all_users, kv[:,0,0] )
        self._all_users = self._all_users[i]

        i = np.in1d( self._all_songs, kv[:,0,1] )
        self._all_songs = self._all_songs[i]

        
    def get_song_score(self,key):
        '''get song score from matrix'''
        
        index = self.index_dictionary[key]
        return self.score_matrix[index]

    def __init_score_matrix(self,path):
        '''initialize score matrix with given song scores from taste space'''
            
            
        # matrix will be indexed lexographically, rowwise by user, columwise by song
        user_count = self.n_users
        song_count = self.get_all_songs().shape[0]   
    
        self.score_matrix = np.zeros((user_count,song_count))
          
        for (key,index) in self.index_dictionary.items():
            self.__add_score(key, index)
        
        
        
        
    
    
    def __add_score(self,key,index):
        if key in self.taste_dictionary:
            self.score_matrix[index] = self.taste_dictionary[key]
            
            
        
    def __get_index_dictionary(self):
        '''
        create a dictionary that maps taste_dictionary (uid,sid) key values to score matrix indices (i,j)
        representing the rating of the jth song (sid) by the ith user (uid)
        '''
        users = sorted(self.get_all_users())[:self.n_users]
        songs = sorted(self.get_all_songs())
        
        indices = [(i,j) for i in range(len(users)) for j in range(len(songs))]
        keys = [(user,song) for user in users for song in songs]
        
        
        index_dictionary = dict(zip(keys,indices)) 
        return index_dictionary
    

    
    
    def __MC_solve(self,path):
        import cvxpy as cp
        
        '''set-up and solve optimization problem and constraints for CVX'''
        n,m = self.score_matrix.shape
        
        X = cp.Variable((n,m))
        objective = cp.Minimize(cp.atoms.normNuc(X))
        constraints = []
        
        # get nonzero matrix entries 
        I,J = np.where(self.score_matrix!=0)
        nonzero_entries = [(i,j) for (i,j) in zip(I,J)]
        
        # define constraints to optimization problem
        print('Setting constraints...')
        for i in range(n):
            for j in range(m):
                if (i,j) in nonzero_entries:
                    C = X[i,j] == self.score_matrix[i,j]
                    constraints.append(C)
                else:
                    # constraining to positive scores only. Not necessary to obtain solution
                    C = X[i,j] >= 0
                    constraints.append(C)
        
        
        problem = cp.Problem(objective,constraints)
        
        print('Solving Matrix Completion Optimization problem...')
        # start = timeit.default_timer()
        problem.solve()  # this takes a while (~53 mins)
        # end = timeit.default_timer()
        
        print('Finished')
        #print(f'Runtime: {end-start}')
        print(f'Status: {problem.status}')
        print(f'Objective: {problem.value}')
        
        np.save(file=path+'completed_score_matrix.npy',arr = X.value) 
        
        return X.value
        
        
        
